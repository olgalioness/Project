 копирует len символов из src в dst. Если строка src короче len оставшаяся часть dst будет заполнена нуль-терминаторами. Возвращает указатель на dst.

 принимают полный размер буфера (не только длину) и гарантируют NUL-завершение результата (если размер больше 0 или
озвращаемое значение функции — длина src, что позволяет легко обнаружить усечение: если возвращаемое значение больше или равно size, то выполнялось усечение.

Функция strlcpy () копирует до размера - 1 символов из строки src в dst , заканчивающейся NUL, и заканчивая результатом NUL.
замена strcpy
для копирования содержимого нуль-терминированной строки в буфер ограниченного размера с защитой от переполнения буфера.
dst — указатель на буфер назначения.
src — указатель на исходную строку.
size — размер буфера назначения.
На счёт несёт не несёт инфу об «усечении»: ты смотришь на буфер и ретерн функции и понимаешь, если ретерн >= буфера, то буфер коротковат и произошло «усечение», то есть в буфер записалось лен - 1 символов от сорс. Дальше уже ап ту ю, что тебе как программисту делать с этой информацией 


.. копирует  не более чем size символов либо оконча src оибо пока не кончится size 
#include "libft.h"

size_t	ft_strlcpy(char *dst, const char *src, size_t size)
{
	size_t	length;
	size_t	index;

	if (src == NULL)
		return (0);
	length = ft_strlen(src);   // размер src
	if (size == 0)					
		return (length);		//если равно 0 то возвращет кол-во
	if (length + 1 > size)
		length = size - 1;      //обрезает до \0      //не более чем size - 1 символов и гарантированно устанавливает в конец строки нулевой символ.
	index = 0;
	while (index < length)
	{
		dst[index] = src[index];
		index++;
	}
	dst[index] = '\0';					добавить вконец "\0"
	return (ft_strlen(src));			проверить вставилось ли все или нет, если обрезалось то длины не совпадут если вставилось все то длины совпадут
}                                       возвращаем длину исходника вернули длину  строки

функция возвращает столько число size_t сколько попытались вставить

#include <string.h>
#include <stdio.h>                       /* для printf() */
 
char  buf[10];                      // буфер размером меньше строки
 
int main()
{  char   *str = "образец строки";
   size_t  sz;
 
   buf[0] = '\0';                   // избыточная инициализация для отладочной печати
 
   printf("строка: \"%s\"\n\n", str);
   printf("буфер перед копированием: \"%s\"\n", buf);
 
   sz = strlcpy(buf, str, sizeof(buf));    
   if (sz >= sizeof(buf))           // пример определения усечения строки      
      printf("обнаружено усечение строки с %d до %d символов !\n", sz, sizeof(buf)-1);
 
   printf("буфер после копирования:  \"%s\"\n", buf);
 
   return 0;
}