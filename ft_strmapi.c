работает аналогично ft_strmap(составляет новую строку путем получения символов от функции f, которая проходит по всем символам исходной строки.), но функция-обработчик также получает порядковый номер символа в исходной строке.
Приходит строка и функция.
Надо создать массив того же размера что и строка, и в каждый элемент записать значение, которое вернёт вызов функции, аргументом которой будет элемент того же номера входящей строки
да. надо пробежать по строке, к каждому символу применить f() и вернуть новую строку с результатом


ам все сложно для понимания и не совсем логично, но в инт передавай индекс.
мы как-то это обсуждали и не нашли ни одного прототипа в библиотеке, который соответствовал бы f().
короче, поведение подразумевает, что ф-ия берет символ и индекс и что-то делает с символом в зависимости от индекса.
так вообще не логично и не правильно так с точки зрения функционального программирования, но тем не менее... просто поверь. если будешь писать свою f() имей ввиду, что в чекере идёт проверка этого инта на чётность.


что-то делает с интом и чаром и возвращает чар
#include "libft.h"

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	char			*result;
	unsigned int	index;

	index = 0;
	if (s == NULL)
		return (NULL);
	result = NULL;													обнулять указаль
	result = (char*)malloc(sizeof(char) * (ft_strlen(s) + 1));     зарезервировали память под строку
	if (result == NULL)
		return (NULL);
	while (s[index] != '\0')
	{
		result[index] = (*f)(index, s[index]);						берем чар и индекс и применяем к ним функцию, а то что получилось в новую строку, разименовали указатель *s
		index++;													применили к каждому элементу строки
	}
	result[index] = '\0';
	return (result);								вернули указатель на начало новой строки
}
